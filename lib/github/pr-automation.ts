/**
 * Automated Pull Request Creation
 * Utilities for creating PRs with generated fixes
 * Copyright ¬© 2025 KilatCode Studio
 */

import { GitHubClient } from './client';

export interface PRCreationOptions {
    owner: string;
    repo: string;
    files: Array<{ path: string; content: string }>;
    title: string;
    description: string;
    branchName?: string;
    baseBranch?: string;
}

export interface PRResult {
    success: boolean;
    prNumber?: number;
    prUrl?: string;
    branchName: string;
    error?: string;
}

/**
 * Create PR with generated code fixes
 */
export async function createAutomatedPR(
    githubClient: GitHubClient,
    options: PRCreationOptions
): Promise<PRResult> {
    const {
        owner,
        repo,
        files,
        title,
        description,
        branchName = `KilatOS-fix-${Date.now()}`,
        baseBranch = 'main'
    } = options;

    try {
        // Step 1: Create branch
        console.log(`üìù Creating branch: ${branchName}`);
        await githubClient.createBranch(owner, repo, branchName, baseBranch);

        // Step 2: Commit files
        console.log(`üíæ Committing ${files.length} file(s)`);
        await githubClient.commitMultipleFiles(
            owner,
            repo,
            branchName,
            files,
            `ü§ñ KilatOS: ${title}`
        );

        // Step 3: Create pull request
        console.log(`üîÄ Creating pull request`);
        const pr = await githubClient.createPullRequest(owner, repo, {
            title: `ü§ñ [KilatOS] ${title}`,
            body: generatePRBody(description, files),
            head: branchName,
            base: baseBranch
        });

        console.log(`‚úÖ PR created: ${pr.url}`);

        return {
            success: true,
            prNumber: pr.number,
            prUrl: pr.url,
            branchName
        };

    } catch (error) {
        console.error('PR creation error:', error);

        return {
            success: false,
            branchName,
            error: error instanceof Error ? error.message : 'Unknown error'
        };
    }
}

/**
 * Generate PR body with details
 */
function generatePRBody(description: string, files: Array<{ path: string; content: string }>): string {
    return `## ü§ñ Automated Fix by KilatOS

${description}

---

### üìù Changes Made

${files.map(f => `- \`${f.path}\``).join('\n')}

**Total files modified:** ${files.length}

---

### ‚úÖ Review Checklist

- [ ] Code changes are correct
- [ ] No breaking changes
- [ ] Tests pass (if applicable)
- [ ] Ready to merge

---

*This PR was automatically generated by [KilatOS](https://github.com/kilatcode/KilatOS) AI Code Audit Agent.*

*Powered by KilatCode Studio üöÄ*`;
}

/**
 * Create PR for code audit fixes
 */
export async function createAuditFixPR(
    githubClient: GitHubClient,
    owner: string,
    repo: string,
    auditResults: {
        issues: Array<{
            file: string;
            issue: string;
            fix: string;
        }>;
        fixes: Record<string, string>;
    }
): Promise<PRResult> {
    const files = Object.entries(auditResults.fixes).map(([path, content]) => ({
        path,
        content
    }));

    const issuesSummary = auditResults.issues
        .map(issue => `- **${issue.file}:** ${issue.issue}`)
        .join('\n');

    const description = `### Issues Found

${issuesSummary}

### Fixes Applied

${auditResults.issues.map(issue => `**${issue.file}:**
${issue.fix}`).join('\n\n')}`;

    return createAutomatedPR(githubClient, {
        owner,
        repo,
        files,
        title: `Fix ${auditResults.issues.length} code issues`,
        description
    });
}

/**
 * Validate repository before creating PR
 */
export async function validateRepository(
    githubClient: GitHubClient,
    owner: string,
    repo: string
): Promise<{ valid: boolean; error?: string }> {
    try {
        // Check if repository exists and user has access
        await githubClient.getRepository(owner, repo);

        return { valid: true };
    } catch (error) {
        return {
            valid: false,
            error: error instanceof Error ? error.message : 'Repository not accessible'
        };
    }
}

/**
 * Check if branch already exists
 */
export async function branchExists(
    githubClient: GitHubClient,
    owner: string,
    repo: string,
    branchName: string
): Promise<boolean> {
    try {
        const client = (githubClient as any).octokit;
        await client.git.getRef({
            owner,
            repo,
            ref: `heads/${branchName}`
        });
        return true;
    } catch {
        return false;
    }
}
